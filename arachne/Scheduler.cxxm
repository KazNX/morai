export module arachne:scheduler;

import std;

import :common;
import :fibre;
import :resumption;

export namespace arachne
{
/// Implements a fibre management and update scheduler for fibres - sometimes known as microthreads.
///
/// The fibre @c Scheduler implements cooperative multitasking in a single thread. Fibres are
/// written as C++20 coroutines. There are two requirements for implementing a fibre entrypoint:
///
/// - The entry point function must have a @c fibre::Fibre return type.
/// - The entry point function must be a C++ coroutine - i.e., use @c co_await, @c co_yield or
///   @c co_return.
///
/// The scheduler supports starting fibres via @c start() and requires @c update() to be called
/// in order to update all known fibres. The provided epoch time must be monotonically increasing,
/// but is otherwise managed by the caller. The time is interpreted as seconds, though the actual
/// rate may be varied by the called.
///
/// All fibres start initially suspended and remain suspended until the next @c update() call.
/// Fibres *must* cede control regularly or starve the @c fibre::Scheduler thread as there is no
/// pre-emption.
///
/// A fibre may cede control in any for the following ways (preferred usage is marked):
///
/// - `co_yield {};` - resume next update. (preferred)
///   - `co_yield fibre::yield();` - resume next update (alias)
///   - `co_await fibre::yield();` - supported alternative
/// - `co_await <double>;` - resume after the specified number of seconds. (preferred)
///   - `co_await std::chrono::duration...;` (alternative preferred)
///   - `co_await fibre::sleep(duration_s);` - resume after duration_s seconds (alias)
///   - `co_yield <sleep-expression>;` - supported alternative
/// - `co_await fibre::wait(condition[, timeout]);` - resume when condition() returns true
///   (preferred)
///   - `co_await []() -> bool { ... };` - resume when the lambda returns true (alternative
///     preferred)
///   - `co_yield fibre::wait(condition[, timeout]);` - supported alternative
/// - `co_return;` - end fibre execution. Implicit on reaching the end of the function.'
///
/// All @c co_await expressions will continue immediately if the condition is already met (not
/// possible when awaiting a @c fibre::yield() ). Conversely, all @c co_yield expressions cede
/// control even if the condition is already met.
///
/// Typical usage of the scheduler is as follows:
///
/// @code
/// int main()
/// {
///   using namespace arachne;
///   Scheduler fibres;     // Create the scheduler
///   startFibres(fibres);  // Start some fibres
///   while (!fibres.empty())
///   {
///     const double epoch_time_s = getEpochTime(); // Get current time
///     fibres.update(epoch_time_s);                // Update all fibres
///     doOtherWork();                              // Do other work
///   }
///   return 0;
/// }
/// @endcode
///
/// Other notes:
///
/// - A @c fibre::Scheduler is not itself thread-safe.
/// - Multiple fibre systems may exist both on the same thread or across multiple threads.
/// - Fibres may not be moved between fibre systems.
/// - @c gls::finally() patterns may be used to ensure some fibre cleanup code is always executed.
/// - Fibres may start other fibres in the same @c Scheduler so long as they have access to the
///   @c Scheduler. New fibres are updated on the *next* @c update() call.
/// - Fibres may cancel other fibres in the same @c Scheduler. This prevents any further updates of
/// the
///   target fibre.
class Scheduler
{
public:
  Scheduler();
  ~Scheduler();

  /// Returns true if there are no running fibres.
  [[nodiscard]] bool empty() const noexcept { return _fibres.empty(); }
  /// Returns the number of running fibres regardless of suspended state.
  [[nodiscard]] std::size_t runningCount() const noexcept { return _fibres.size(); }
  /// Check if there is a fibre running with the given ID.
  [[nodiscard]] bool isRunning(Id fibre_id) const noexcept;

  Id start(Fibre &&fibre);
  bool cancel(Id fibre_id);
  std::size_t cancel(std::span<const Id> fibre_ids);

  /// Generate a wait condition to wait until the specified fibre is no longer
  /// running.
  /// @param fibre_id The fibre ID to wait for.
  /// @return The wait condition. Can be used with @c co_await in a fibre.
  WaitCondition await(const Id fibre_id) const noexcept
  {
    return [this, fibre_id]() -> bool { return !isRunning(fibre_id); };
  }

  void cancelAll();

  void update(double epoch_time_s);

private:
  struct FibreEntry
  {
    Id id = InvalidFibre;
    Fibre fibre;
    bool cancel = false;
  };

  struct Expiry
  {
    std::vector<std::size_t> indices;
    std::vector<FibreEntry> fibres;

    void clear()
    {
      indices.clear();
      fibres.clear();
    }
  };

  bool cancel(std::vector<FibreEntry> &fibres, Expiry &expiry, Id fibre_id) const;
  std::size_t cancel(std::vector<FibreEntry> &fibres, Expiry &expiry,
                     std::span<const Id> fibre_ids) const;
  void cleanupFibres(Expiry &expiry);

  std::vector<FibreEntry> _fibres{};
  /// Fibres added during an update. Migrated at the end of the update.
  std::vector<FibreEntry> _new_fibres{};
  Id _next_id = 0u;
  Expiry _expiry{};
  bool _in_update = false;
};
}  // namespace arachne
